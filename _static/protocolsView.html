<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Protocols Hierarchical Map</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; overflow: hidden; }
    #graph { width: 100vw; height: 100vh; }
    .tooltip {
      position: absolute;
      text-align: left;
      width: 300px;
      padding: 8px;
      font-size: 13px;
      background: rgba(0,0,0,0.85);
      color: #fff;
      border-radius: 6px;
      pointer-events: none;
      opacity: 0;
    }
    .highlight { stroke: black !important; stroke-width: 3px; }
    .dimmed { opacity: 0.2; }
    .legend {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 6px;
      font-size: 12px;
      max-height: 90vh;
      overflow-y: auto;
      z-index: 10;
    }
    text { pointer-events: none; user-select: none; }
  </style>
</head>
<body>
<div class="legend">
  <strong>Instructions:</strong>
  <ul style="margin:5px 0 0 15px; padding:0;">
    <li>Use the mouse to <strong>zoom</strong> and move the graph.</li>
    <li><strong>Hover</strong> over a protocol node to see more information.</li>
    <li><strong>Click</strong> on a node to highlight its connections.</li>
    <li><strong>Click and drag</strong> the mouse to move around the map.</li>
  </ul>
</div>

<div id="graph"></div>
<div id="tooltip" class="tooltip"></div>

<script>
d3.json("protocolsInfo.json").then(data => {

  function buildHierarchicalGraph(data) {
    const nodes = [];
    const links = [];
    const level1Set = new Set();
    const level2Set = new Set();
    const level3Set = new Set();

    Object.entries(data).forEach(([id, proto]) => {
      const tags = proto.Tags[0];
      const lvl1 = tags[0], lvl2 = tags[1], lvl3 = tags[2];

      if (!level1Set.has(lvl1)) { nodes.push({id:`lvl1-${lvl1}`, type:"lvl1", nombre:lvl1}); level1Set.add(lvl1); }
      if (lvl2 && !level2Set.has(lvl1+"-"+lvl2)) {
        nodes.push({id:`lvl2-${lvl1}-${lvl2}`, type:"lvl2", nombre:lvl2});
        links.push({source:`lvl1-${lvl1}`, target:`lvl2-${lvl1}-${lvl2}`});
        level2Set.add(lvl1+"-"+lvl2);
      }
      if (lvl3 && !level3Set.has(lvl1+"-"+lvl2+"-"+lvl3)) {
        nodes.push({id:`lvl3-${lvl1}-${lvl2}-${lvl3}`, type:"lvl3", nombre:lvl3});
        links.push({source:`lvl2-${lvl1}-${lvl2}`, target:`lvl3-${lvl1}-${lvl2}-${lvl3}`});
        level3Set.add(lvl1+"-"+lvl2+"-"+lvl3);
      }

      nodes.push({id, type:"protocol", nombre:proto.name, descripcion:proto.Description});
      const parentId = lvl3 ? `lvl3-${lvl1}-${lvl2}-${lvl3}` : (lvl2 ? `lvl2-${lvl1}-${lvl2}` : `lvl1-${lvl1}`);
      links.push({source: parentId, target:id});
    });

    return {nodes, links};
  }

  const graph = buildHierarchicalGraph(data);

  const color = d3.scaleOrdinal()
    .domain(["lvl1","lvl2","lvl3","protocol"])
    .range(["#c12e2a", "#4F1271", '#F6AE2D', "#808080"]);

  const svg = d3.select("#graph").append("svg")
    .attr("width","100%").attr("height","100%");

  const g = svg.append("g");
  svg.call(d3.zoom().on("zoom", (event)=>{ g.attr("transform", event.transform); }));

  const tooltip = d3.select("#tooltip");

  const link = g.append("g")
    .attr("stroke","black").attr("stroke-opacity",0.6)
    .selectAll("line").data(graph.links)
    .join("line").attr("stroke-width",1);

  const node = g.append("g")
    .selectAll("circle").data(graph.nodes)
    .join("circle")
    .attr("r", d=>d.type==="protocol"?6:(d.type==="lvl1"?20:(d.type==="lvl2"?14:10)))
    .attr("fill", d=>color(d.type))
    .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

  // Labels para todos los nodos
  const labels = g.append("g").selectAll("text")
    .data(graph.nodes)
    .join("text")
    .text(d => d.nombre)
    .attr("font-size", d => d.type==="lvl1"?18 : d.type==="lvl2"?12 : d.type==="lvl3"?10:7)
    .attr("fill", d => d.type==="protocol"?"#444":"#000")
    .attr("font-weight", d => d.type==="lvl1"?"bold":"normal")  // ← Nivel 1 en negrita
    .attr("text-anchor", "start")
    .attr("dy", "0.35em");

  // Tooltips
  node.on("mouseover", (event, d) => {
    tooltip.transition().duration(200).style("opacity", 0.95);
    if (d.type === "protocol") {
      tooltip.html(`<strong>${d.nombre}</strong><br/><br/>${d.descripcion}`);
    } else if (d.type === "lvl3") {
      const childProtocols = graph.links
        .filter(l => l.source.id === d.id)
        .map(l => graph.nodes.find(n => n.id === l.target.id && n.type==="protocol"))
        .filter(n => n).map(n => n.nombre);
      tooltip.html(`${d.nombre}<br/><br><strong>Protocols:</strong><br>${childProtocols.join("<br>")}`);
    } else {
      tooltip.html(`${d.nombre}`);
    }
    tooltip.style("left", (event.pageX+15)+"px").style("top",(event.pageY+15)+"px");
  }).on("mousemove", (event) => {
    tooltip.style("left", (event.pageX+15)+"px").style("top",(event.pageY+15)+"px");
  }).on("mouseout", () => tooltip.transition().duration(200).style("opacity",0));

  // Click highlight
  node.on("click", (event,d) => {
    event.stopPropagation();
    link.classed("highlight", false).classed("dimmed", true);
    node.classed("dimmed", true);

    function getDescendants(nodeId){
      const children = graph.links.filter(l=>l.source.id===nodeId).map(l=>l.target.id);
      return children.concat(children.flatMap(getDescendants));
    }

    const descendants = getDescendants(d.id);
    link.filter(l=>descendants.includes(l.target.id)).classed("highlight",true).classed("dimmed",false);
    node.filter(n=>descendants.includes(n.id)||n.id===d.id).classed("dimmed",false);
  });

  svg.on("click", (event)=>{
    if(event.target===svg.node()){
      link.classed("highlight",false).classed("dimmed",false);
      node.classed("dimmed",false);
    }
  });

  const chargeForce = d3.forceManyBody()
    .strength(d => d.type==="lvl1"? -250 : d.type==="lvl2"? -120 : d.type==="lvl3"? -50 : -30);

  const simulation = d3.forceSimulation(graph.nodes)
    .force("link", d3.forceLink(graph.links).id(d=>d.id).distance(50))
    .force("charge", chargeForce)
    .force("center", d3.forceCenter(window.innerWidth/2, window.innerHeight/2))
    .force("collide", d3.forceCollide().radius(d=>d.type==="protocol"?12:25))
    .force("x", d3.forceX(window.innerWidth/2).strength(0.01))
    .force("y", d3.forceY(window.innerHeight/2).strength(0.01));

  simulation.on("tick",()=>{
    link.attr("x1",d=>d.source.x).attr("y1",d=>d.source.y)
        .attr("x2",d=>d.target.x).attr("y2",d=>d.target.y);
    node.attr("cx",d=>d.x).attr("cy",d=>d.y);
    labels.attr("x", d => {
      if(d.type==="lvl1") return d.x + 22;
      else if(d.type==="lvl2") return d.x + 18;
      else if(d.type==="lvl3") return d.x + 14;
      else return d.x + 8;
    }).attr("y", d => d.y);
  });

  function dragstarted(event,d){if(!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y;}
  function dragged(event,d){d.fx=event.x; d.fy=event.y;}
  function dragended(event,d){if(!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null;}

}).catch(error => { console.error("Error al cargar JSON:", error); });
</script>
</body>
</html>
