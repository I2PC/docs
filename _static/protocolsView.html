
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Protocols Hierarchical Map</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; overflow: hidden; }
    #graph { width: 100vw; height: 100vh; }
    .tooltip {
      position: absolute;
      text-align: left;
      width: 300px;
      padding: 8px;
      font-size: 13px;
      background: rgba(0,0,0,0.85);
      color: #fff;
      border-radius: 6px;
      pointer-events: none;
      opacity: 0;
    }

    
  </style>
</head>
<body>
<div id="instructions" style="
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255,255,255,0.9);
    border: 1px solid #ccc;
    padding: 10px 12px;
    border-radius: 6px;
    font-size: 13px;
    max-width: 300px;
    box-shadow: 2px 2px 8px rgba(0,0,0,0.2);
    z-index: 10;
">
  <strong>Instructions:</strong>
  <ul style="margin: 5px 0 0 15px; padding:0;">
    <li>Use the mouse to <strong>zoom</strong> and move the graph.</li>
    <li><strong>Hover</strong> over a protocol node to see more information.</li>
    <li><strong>Click and drag</strong> the mouse to move around the map.</li>
  </ul>
</div>

<div id="graph"></div>
<div id="tooltip" class="tooltip"></div>
<div id="legend" class="legend"></div>

<script>
d3.json("protocolsInfo.json").then(data => {
 //  To update the data run the protocolCollectInfo.py script located in scipion-em-xmipp repository in your laptop qith scipion and xmipp installed (revire the constant inside the script)

  // Construir grafo jerárquico
  function buildHierarchicalGraph(data) {
    const nodes = [];
    const links = [];
    const level1Set = new Set();
    const level2Set = new Set();
    const level3Set = new Set();

    Object.entries(data).forEach(([id, proto]) => {
      const tags = proto.Tags[0];
      const lvl1 = tags[0], lvl2 = tags[1], lvl3 = tags[2];

      if (!level1Set.has(lvl1)) { nodes.push({id:`lvl1-${lvl1}`, type:"lvl1", nombre:lvl1}); level1Set.add(lvl1); }
      if (lvl2 && !level2Set.has(lvl1+"-"+lvl2)) {
        nodes.push({id:`lvl2-${lvl1}-${lvl2}`, type:"lvl2", nombre:lvl2});
        links.push({source:`lvl1-${lvl1}`, target:`lvl2-${lvl1}-${lvl2}`});
        level2Set.add(lvl1+"-"+lvl2);
      }
      if (lvl3 && !level3Set.has(lvl1+"-"+lvl2+"-"+lvl3)) {
        nodes.push({id:`lvl3-${lvl1}-${lvl2}-${lvl3}`, type:"lvl3", nombre:lvl3});
        links.push({source:`lvl2-${lvl1}-${lvl2}`, target:`lvl3-${lvl1}-${lvl2}-${lvl3}`});
        level3Set.add(lvl1+"-"+lvl2+"-"+lvl3);
      }

      nodes.push({id, type:"protocol", nombre:proto.name, descripcion:proto.Description});
      const parentId = lvl3 ? `lvl3-${lvl1}-${lvl2}-${lvl3}` : (lvl2 ? `lvl2-${lvl1}-${lvl2}` : `lvl1-${lvl1}`);
      links.push({source: parentId, target:id});
    });

    return {nodes, links};
  }

  const graph = buildHierarchicalGraph(data);

  // Colores por nivel
  const color = d3.scaleOrdinal()
    .domain(["lvl1","lvl2","lvl3","protocol"])
    .range(["#c12e2a", "#4F1271", '#F6AE2D', "#808080"]);

  const svg = d3.select("#graph").append("svg")
    .attr("width","100%").attr("height","100%");

  const g = svg.append("g");
  svg.call(d3.zoom().on("zoom", (event)=>{ g.attr("transform", event.transform); }));

  const tooltip = d3.select("#tooltip");

  const link = g.append("g")
    .attr("stroke","#aaa").attr("stroke-opacity",0.6)
    .selectAll("line").data(graph.links)
    .join("line").attr("stroke-width",1);

  const node = g.append("g")
    .selectAll("circle").data(graph.nodes)
    .join("circle")
    .attr("r", d=>d.type==="protocol"?6:(d.type==="lvl1"?20:(d.type==="lvl2"?14:10)))
    .attr("fill", d=>color(d.type))
    .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

  // Etiquetas para cada nivel
  const labels1 = g.append("g").selectAll("text")
    .data(graph.nodes.filter(d=>d.type==="lvl1")).join("text")
    .text(d=>d.nombre).attr("font-size","14px").attr("font-weight","bold").attr("fill","#000")
    .attr("text-anchor","start").attr("dy","0.35em");

  const labels2 = g.append("g").selectAll("text")
    .data(graph.nodes.filter(d=>d.type==="lvl2")).join("text")
    .text(d=>d.nombre).attr("font-size","12px").attr("fill","#333")
    .attr("text-anchor","start").attr("dy","0.35em");

  const labels3 = g.append("g").selectAll("text")
    .data(graph.nodes.filter(d=>d.type==="lvl3")).join("text")
    .text(d=>d.nombre).attr("font-size","10px").attr("fill","#333")
    .attr("text-anchor","start").attr("dy","0.35em");

node.on("mouseover", (event, d) => {
  tooltip.transition().duration(200).style("opacity", 0.95);

  if(d.type === "protocol") {
    // Nodo protocolo: mostrar su descripción
    tooltip.html(`<strong>${d.nombre}</strong><br/><br/>${d.descripcion}`);
  } else if(d.type === "lvl2") {
    // Nodo de nivel 2: mostrar protocolos hijos
    const childProtocols = graph.links
      .filter(link => link.source.id === d.id)   // todos los links desde este nodo
      .map(link => graph.nodes.find(n => n.id === link.target.id && n.type === "protocol"))
      .filter(n => n)                             // descartar nulls si hay
      .map(n => n.nombre);

    tooltip.html(`<strong>${d.type}:</strong> ${d.nombre}<br/><br/><strong>Protocols:</strong><br>${childProtocols.join("<br>")}`);
  } else {
    // Nodo de nivel 1 o 3: mostrar solo el nombre
    tooltip.html(`<strong>${d.type}:</strong> ${d.nombre}`);
  }

  tooltip.style("left", (event.pageX + 15) + "px")
         .style("top", (event.pageY + 15) + "px");
})
.on("mousemove", (event) => {
  tooltip.style("left", (event.pageX + 15) + "px")
         .style("top", (event.pageY + 15) + "px");
})
.on("mouseout", () => tooltip.transition().duration(200).style("opacity", 0));


  const chargeForce = d3.forceManyBody()
    .strength(d => d.type==="lvl1"? -200 : d.type==="lvl2"? -50 : d.type==="lvl3"? -20 : -20);

  const simulation = d3.forceSimulation(graph.nodes)
    .force("link", d3.forceLink(graph.links).id(d=>d.id).distance(50))
    .force("charge", chargeForce)
    .force("center", d3.forceCenter(window.innerWidth/2, window.innerHeight/2))
    .force("collide", d3.forceCollide().radius(d=>d.type==="protocol"?12:25))
    .force("x", d3.forceX(window.innerWidth/2).strength(0.01))
    .force("y", d3.forceY(window.innerHeight/2).strength(0.01));

  simulation.on("tick",()=>{
    link.attr("x1",d=>d.source.x).attr("y1",d=>d.source.y)
        .attr("x2",d=>d.target.x).attr("y2",d=>d.target.y);

    node.attr("cx",d=>d.x).attr("cy",d=>d.y);

    labels1.attr("x", d => d.x + 22).attr("y", d => d.y);
    labels2.attr("x", d => d.x + 18).attr("y", d => d.y);
    labels3.attr("x", d => d.x + 14).attr("y", d => d.y);
  });

  function dragstarted(event,d){if(!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y;}
  function dragged(event,d){d.fx=event.x; d.fy=event.y;}
  function dragended(event,d){if(!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null;}

  // Leyenda
  const legend = d3.select("#legend");
  legend.append("strong").text("Level 1");
  graph.nodes.filter(d=>d.type==="lvl1").forEach(d=>{
    const entry = legend.append("div");
    entry.append("span").style("background", color(d.type));
    entry.append("text").text(d.nombre);
  });

  legend.append("strong").text("Level 2");
  graph.nodes.filter(d=>d.type==="lvl2").forEach(d=>{
    const entry = legend.append("div");
    entry.append("span").style("background", color(d.type));
    entry.append("text").text(d.nombre);
  });

}).catch(error => {
  console.error("Error al cargar el JSON:", error);
});
</script>
</body>
</html>
